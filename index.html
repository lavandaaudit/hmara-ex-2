<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IBONIRIUM · 3D Cloud + Star Indicators</title>

<style>
  body { margin:0; overflow:hidden; background:#0a0e14; }
  #info{
    position:absolute; top:16px; left:16px; font-family: monospace;
    color:#aaffcc; font-size:12px; line-height:1.4; text-shadow:0 0 4px #000;
  }
  #info b{ color:#6fffa0; }
</style>
</head>
<body>
<div id="info">
  <div>Weather: <b><span id="wcode">–</span></b></div>
  <div>Cloud cover: <b><span id="cc">–</span>%</b></div>
  <div>Humidity: <b><span id="hum">–</span>%</b></div>
  <div>Wind: <b><span id="wind">–</span> m/s</b></div>
  <div>Visibility: <b><span id="vis">–</span> km</b></div>
  <div>Solar index: <b><span id="solar">–</span></b></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>

<script>
let scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0e14, 0.035);

let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
camera.position.set(0, 80, 200);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0a0e14);
document.body.appendChild(renderer.domElement);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.1;
controls.minDistance = 50;
controls.maxDistance = 500;

// ==================================================
// 3D Хмара
const particleCount = 12000;
let particles = new THREE.BufferGeometry();
let positions = new Float32Array(particleCount*3);
let velocities = new Float32Array(particleCount*3);
let colors = new Float32Array(particleCount*3);

for(let i=0;i<particleCount;i++){
  positions[i*3] = (Math.random()-0.5)*200;
  positions[i*3+1] = (Math.random()-0.5)*100;
  positions[i*3+2] = (Math.random()-0.5)*200;

  velocities[i*3] = (Math.random()-0.5)*0.1;
  velocities[i*3+1] = (Math.random()-0.5)*0.05;
  velocities[i*3+2] = (Math.random()-0.5)*0.1;

  colors[i*3] = 0.9 + Math.random()*0.1;
  colors[i*3+1] = 0.9 + Math.random()*0.1;
  colors[i*3+2] = 1.0;
}

particles.setAttribute('position', new THREE.BufferAttribute(positions,3));
particles.setAttribute('color', new THREE.BufferAttribute(colors,3));

let material = new THREE.PointsMaterial({
  size: 2.0,
  vertexColors:true,
  transparent:true,
  opacity:0.7,
  depthWrite:false,
  blending:THREE.AdditiveBlending
});

let cloud = new THREE.Points(particles, material);
scene.add(cloud);

// ==================================================
// Блискавки
let flash = new THREE.PointLight(0xffffff,0,400);
scene.add(flash);

// ==================================================
// Показники-зірки
function createStarIndicator(x, y, z){
  const geometry = new THREE.IcosahedronGeometry(5,1);
  const material = new THREE.MeshStandardMaterial({color:0xffff33, emissive:0xffff33, emissiveIntensity:1});
  const star = new THREE.Mesh(geometry, material);
  star.position.set(x, y, z);
  scene.add(star);
  return star;
}

let star1 = createStarIndicator(-50,-80,0);
let star2 = createStarIndicator(50,-80,0);

let ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

let windSpeed=0, windDir=0, cloudCover=50, humidity=50, visibility=10, weatherCode=0;
let solarIndex=0;

// ==================================================
// Турбулентні локальні вихори
function applyCyclones(t){
  const count = Math.max(1, Math.floor(windSpeed/2));
  for(let c=0;c<count;c++){
    const cx = (Math.random()-0.5)*100;
    const cy = (Math.random()-0.5)*50;
    const cz = (Math.random()-0.5)*100;
    const strength = 0.5 + Math.random()*0.5;
    for(let i=0;i<particleCount;i++){
      let dx = positions[i*3]-cx;
      let dy = positions[i*3+1]-cy;
      let dz = positions[i*3+2]-cz;
      let d = Math.sqrt(dx*dx+dy*dy+dz*dz);
      if(d<20){
        positions[i*3] += -dy*0.01*strength;
        positions[i*3+1] += dx*0.01*strength;
      }
    }
  }
}

// ==================================================
// Оновлення погоди та сонця
async function updateWeather(){
  try{
    const r = await fetch(
      'https://api.open-meteo.com/v1/forecast?latitude=50.45&longitude=30.52&current='+
      'relative_humidity_2m,cloud_cover,weather_code,wind_speed_10m,wind_direction_10m,visibility,temperature_2m'
    );
    const d = await r.json();
    const c = d.current;

    weatherCode=c.weather_code;
    cloudCover=c.cloud_cover??50;
    humidity=c.relative_humidity_2m??50;
    windSpeed=c.wind_speed_10m??0;
    windDir=c.wind_direction_10m??0;
    visibility=(c.visibility??10000)/1000;

    // UI
    wcode.textContent = weatherCode;
    cc.textContent = cloudCover;
    hum.textContent = humidity;
    wind.textContent = windSpeed.toFixed(1);
    vis.textContent = visibility.toFixed(1);

  }catch(e){ console.warn(e); }

  // Симуляція сонячного індексу (API NOAA або реальне можна підключити)
  try{
    const solar = Math.random()*10; // тимчасово випадкове
    solarIndex = solar;
    solarEl.textContent = solarIndex.toFixed(1);

    // колір зірок змінюємо
    const color1 = new THREE.Color(`hsl(${50 + solarIndex*12}, 100%, 50%)`);
    const color2 = new THREE.Color(`hsl(${150 + solarIndex*12}, 100%, 50%)`);
    star1.material.color.copy(color1);
    star1.material.emissive.copy(color1);
    star2.material.color.copy(color2);
    star2.material.emissive.copy(color2);
  }catch(e){}
}

const solarEl = document.getElementById("solar");
updateWeather();
setInterval(updateWeather,15*60*1000);

// ==================================================
function animate(){
  requestAnimationFrame(animate);

  const t = Date.now()*0.002;

  // дихання хмари
  for(let i=0;i<particleCount;i++){
    positions[i*3+1] += Math.sin(t+i*0.1)*0.002;
    positions[i*3] += velocities[i*3]*0.5;
    positions[i*3+2] += velocities[i*3+2]*0.5;
  }

  // локальні вихори
  applyCyclones(t);

  particles.attributes.position.needsUpdate=true;

  // блискавки
  if(weatherCode>=95 && Math.random()<0.003){
    flash.position.set(
      (Math.random()-0.5)*150,
      (Math.random()-0.5)*80,
      (Math.random()-0.5)*150
    );
    flash.intensity=3+Math.random()*2;
  }else{
    flash.intensity*=0.95;
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
