<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>IBONIRIUM · Cloud Barometer · Storm Edition</title>

<style>
body{
  margin:0;
  height:100vh;
  background:#0a0e14;
  font-family: monospace;
  color:#aaffcc;
  overflow:hidden;
}

#device{
  position:fixed;
  top:16px;
  left:16px;
  width:280px;
  height:220px;
  pointer-events:none;
}

canvas{ position:absolute; inset:0; }

#info{
  position:absolute;
  top:8px;
  left:12px;
  font-size:11px;
  line-height:1.38;
  color:#c8ffdc;
  text-shadow:0 0 4px rgba(0,0,0,0.85);
}

#info b{ color:#6fffa0; }

#title{
  font-size:13px;
  color:#9affe0;
  margin-bottom:4px;
  letter-spacing:0.6px;
}
</style>
</head>

<body>

<div id="device">
  <canvas id="cloud"></canvas>
  <div id="info">
    <div id="title">IBONIRIUM · CLOUD BAROMETER</div>
    <div>Weather: <b><span id="wcode">–</span></b></div>
    <div>Cloud cover: <b><span id="cc">–</span>%</b></div>
    <div>Humidity: <b><span id="hum">–</span>%</b></div>
    <div>Wind: <b><span id="wind">–</span> m/s</b></div>
    <div>Visibility: <b><span id="vis">–</span> km</b></div>
    <div>Cloud factor: <b><span id="cf">–</span></b></div>
  </div>
</div>

<script>
const canvas = document.getElementById('cloud');
const ctx = canvas.getContext('2d');
canvas.width = 280;
canvas.height = 220;

// ==================================================
let cloudCover=0, humidity=50, weatherCode=0;
let windSpeed=0, windDir=0, visibility=10;
let cloudFactor=1, temperature=10;
let baseColor={r:240,g:245,b:255};

// ==================================================
// простий шум
function noise(x,y){ return Math.sin(x*17.13+y*91.77+Math.sin(y*4))*0.5+0.5; }

// ==================================================
function getCloudColor(code){
  if(code===0) baseColor={r:252,g:252,b:255};
  else if(code<=3) baseColor={r:235,g:240,b:255};
  else if(code<50) baseColor={r:220,g:225,b:255};
  else baseColor={r:200,g:215,b:255};
}

// ==================================================
// циклони (міні-спіралі)
function generateCyclones(){
  const count = Math.max(1,Math.floor(windSpeed/2));
  const cyclones = [];
  for(let i=0;i<count;i++){
    cyclones.push({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height,
      strength: 0.6+Math.random()*0.7,
      radius: 18+Math.random()*20
    });
  }
  return cyclones;
}
let cyclones = generateCyclones();

// ==================================================
function drawCloud(){
  const t = Date.now()*0.0005;
  const w=canvas.width, h=canvas.height;
  const cx=w*0.52, cy=h*0.5;

  ctx.clearRect(0,0,w,h);

  const windX = Math.cos(windDir*Math.PI/180)*windSpeed*0.08;
  const windY = Math.sin(windDir*Math.PI/180)*windSpeed*0.05;

  const turbulence = Math.max(0,(windSpeed-6)/6);
  const fogFactor = Math.max(0,1-visibility/5);

  const baseSize = 64 + cloudCover*0.45;
  const layers = 5;

  // ======================
  // малюємо хмару
  for(let i=0;i<layers;i++){
    const scale = 0.009 + i*0.003;
    ctx.globalAlpha=(0.22+i*0.1)*(humidity/120+0.5);

    for(let y=0;y<h;y+=3){
      for(let x=0;x<w;x+=3){
        let nx=(x-cx)*scale + windX*t;
        let ny=(y-cy)*scale + windY*t;

        // турбулентність
        if(turbulence>0){
          nx += noise(ny*2,t)*turbulence*0.8;
          ny += noise(nx*2,t+10)*turbulence*0.8;
        }

        // локальні циклончики
        cyclones.forEach(c=>{
          const dx = x-c.x;
          const dy = y-c.y;
          const d = Math.hypot(dx,dy);
          if(d<c.radius){
            const angle = Math.atan2(dy,dx) + t*c.strength;
            const r = d;
            nx += Math.cos(angle)*r*0.02*c.strength;
            ny += Math.sin(angle)*r*0.02*c.strength;
          }
        });

        let n = noise(nx+t,ny)*0.6 + noise(nx*2.2,ny*2.2+t)*0.4;
        const dist = Math.hypot(x-cx,y-cy)/baseSize;
        let falloff = Math.max(0,1-dist*dist*1.35);

        if(turbulence>0){
          const tear = noise(nx*3+t,ny*3)*turbulence;
          falloff -= tear*0.35;
        }
        falloff*=Math.max(0.4,1-fogFactor*0.6);

        // блискавки
        if(weatherCode>=95 && Math.random()<0.001){
          ctx.fillStyle='rgba(255,255,200,0.8)';
          ctx.fillRect(x,y,3,3);
        }else if(n*falloff>0.38){
          const br=n*1.2;
          ctx.fillStyle=`rgba(
            ${Math.min(255,baseColor.r*br)},
            ${Math.min(255,baseColor.g*br)},
            ${Math.min(255,baseColor.b*br)},
            ${falloff}
          )`;
          ctx.fillRect(x,y,3,3);
        }
      }
    }
  }
  ctx.globalAlpha=1;

  drawFog(fogFactor,t);
  drawRain(t);
}

// ==================================================
function drawFog(f,t){
  if(f<=0) return;
  ctx.globalAlpha=0.15*f;
  ctx.fillStyle='rgba(220,235,255,0.6)';
  ctx.beginPath();
  ctx.ellipse(
    canvas.width/2,
    canvas.height/2+Math.sin(t)*8,
    canvas.width*0.55,
    canvas.height*0.35,
    0,0,Math.PI*2
  );
  ctx.fill();
  ctx.globalAlpha=1;
}

// ==================================================
function drawRain(t){
  if(weatherCode<51) return;
  const count = Math.min(160,(cloudCover+humidity)*0.9);
  const angle = windDir*Math.PI/180;
  const vx = Math.sin(angle)*windSpeed*1.4;
  const vy = Math.cos(angle)*windSpeed*3.2;

  ctx.strokeStyle='rgba(180,220,255,0.35)';
  ctx.lineWidth=1;
  for(let i=0;i<count;i++){
    const x=(i*17+t*90)%canvas.width;
    const y=(i*47+t*130)%canvas.height;
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.lineTo(x+vx,y+vy);
    ctx.stroke();
  }
}

// ==================================================
async function updateWeather(){
  try{
    const r = await fetch(
      'https://api.open-meteo.com/v1/forecast?latitude=50.45&longitude=30.52&current='+
      'relative_humidity_2m,cloud_cover,weather_code,'+
      'wind_speed_10m,wind_direction_10m,visibility,temperature_2m'
    );
    const d = await r.json();
    const c = d.current;

    weatherCode=c.weather_code;
    cloudCover=c.cloud_cover??0;
    humidity=c.relative_humidity_2m??50;
    windSpeed=c.wind_speed_10m??0;
    windDir=c.wind_direction_10m??0;
    visibility=(c.visibility??10000)/1000;
    temperature=c.temperature_2m??10;

    cloudFactor=0.6+cloudCover/45+humidity/200+windSpeed/16;

    getCloudColor(weatherCode);

    wcode.textContent=weatherCode;
    cc.textContent=cloudCover;
    hum.textContent=humidity;
    wind.textContent=windSpeed.toFixed(1);
    vis.textContent=visibility.toFixed(1);
    cf.textContent=cloudFactor.toFixed(2);

    // нові циклончики при зміні вітру
    cyclones = generateCyclones();

  }catch(e){ console.warn("weather error",e); }
}

updateWeather();
setInterval(updateWeather,15*60*1000);

// ==================================================
function loop(){
  drawCloud();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
